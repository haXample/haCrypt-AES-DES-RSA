// haCrypt - Crypto tool for DES, AES, TDEA and RSA.
// haCryptDialog.cpp - C++ Developer source file.
// (c)2021 by helmut altmann

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; see the file COPYING.  If not, write to
// the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.

#include <fcntl.h>   // Console
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <iostream>
#include <conio.h>

#include <shlwapi.h>  // Library shlwapi.lib for PathFileExistsA
#include <commctrl.h> // Library Comctl32.lib
#include <commdlg.h>
#include <winuser.h>  // contains: #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) typedef HANDLE HDWP; #endif                                                                            
#include <windows.h>

#include <string.h>
#include <string>     // sprintf, etc.
#include <tchar.h>     
#include <strsafe.h>  // <strsafe.h> must be included after <tchar.h>

#include <propkey.h>
#include <propvarutil.h>

#include <shlwapi.h>  // Library shlwapi.lib for PathFileExistsA, PathFindExtensionW

typedef HANDLE HDWP;	// needed in <shlobj_core.h> for 'x64' ha reduced VC 2019 installation 
#include <shlobj.h>   // Typical Shell header file, for browsing directory info (#include(s) <shlobj_core.h>!)
#include <shobjidl.h> // For CBTSHBrowseForFolder

#include <objbase.h>

#include "haCrypt.h"

// Global variables
TCHAR szErrorRename[] = _T("Rename text must start with: *.\n \
1st  char = * (Wildcard for filename)\n \
2nd char = . (Dot for file extension)");
TCHAR szErrorFormat[] = _T("Wrong format for file extension.");
TCHAR szDfltWildcards[] = _T("*.???");

TCHAR oldFileExtension[20] = _T("");
TCHAR newFileExtension[20] = _T("");

// Extern variables
extern char DebugBuf[];      // Debug only, buffer for formatted ASCII text
extern TCHAR _tDebugBuf[];   // Temporary buffer for formatted UNICODE text
extern int _tDebugbufSize;

extern int _valAQ, _cbtFolderFlag;

extern TCHAR szFileExtension[];
extern TCHAR szExtensionSave[];

extern TCHAR szSignonTitle[];
extern TCHAR _tKeyIcvBuf[];  // Temporary buffer for formatted UNICODE text
extern TCHAR _tTimeBuf[];    // File Time&Date
extern TCHAR szPathSave[];

extern TCHAR* pszCurrentModeTooltip;

extern PWSTR szTruncPath;

extern COLORREF INFO_FGND; // Green (Painted Text string) 
extern COLORREF COPY_FGND; // Blue  (Painted Text string) 

extern HWND hMain;

extern BOOL GetBuildTime(TCHAR*, LPTSTR, DWORD);
extern void TruncateFilePath(PWSTR, int, int);  
extern void ShowActualKeyIv(int);

extern HFONT SetFont(LPCWSTR, int, int);
extern int CustomMessageBox(HWND, LPCTSTR, LPCTSTR, UINT, UINT);

// Forward declaration of functions included in this code module:
void CenterInsideParent(HWND, char*);

int CBTMessageBox(HWND, LPCTSTR, LPCTSTR, UINT);
LRESULT CALLBACK CBTProc(INT, WPARAM, LPARAM);

//-----------------------------------------------------------------------------
//
//                           AboutDlgProc
//
INT_PTR CALLBACK AboutDlgProc(HWND _hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
  {
  switch(Message)
    {
    case WM_INITDIALOG:
      // Initialize version string in *.rc resource file
#ifdef x64  // 64bit
      GetBuildTime(_T("haCrypt64.exe"), _tTimeBuf, MAX_PATH);  // Generated by VB-Script with NMAKE
#else       // 32bit (XP)
      GetBuildTime(_T("haCrypt.exe"), _tTimeBuf, MAX_PATH);    // Generated by VB-Script with NMAKE
#endif
      StringCbPrintf(_tDebugBuf, _tDebugbufSize, _T("%s  %s"), szSignonTitle, _tTimeBuf);
      SetDlgItemText(_hwnd, IDC_SHOWVERSION, _tDebugBuf);
      return TRUE;

    // Text Color in some of the help windows
    case WM_CTLCOLORSTATIC:
      switch(GetDlgCtrlID((HWND)lParam)) // Get IDC_.. from 'haCrypt.rc' resource
        {
        case IDC_TEXTFIELD:              // Strings displayd in dark blue color
        case IDC_KEYFILE:
        case IDC_MULTIFILE:
        case IDC_CIPH_STEALING:
        case IDC_PADDING_ISO:  
        case IDC_PADDING_PKCS:
        case IDC_TEXT_RSAQUICK:
        case IDC_TEXT_AESQUICK:
        case IDC_TEXT_QUICK:
          { 
          HBRUSH retVal = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
          SetTextColor((HDC)wParam, COPY_FGND); // Dark blue - RGB(005, 020, 100)
          SetBkMode((HDC)wParam, TRANSPARENT);
          return (INT_PTR)retVal;
          }
        case IDC_TEST:
          { 
          HBRUSH retVal = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
          SetTextColor((HDC)wParam, INFO_FGND); // Dark green - RGB(005, 100, 020)
          SetBkMode((HDC)wParam, TRANSPARENT);
          return (INT_PTR)retVal;
          }
        } // end switch
      return 0;

    case WM_COMMAND:
      switch(LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:
          EndDialog(_hwnd, IDCANCEL);
          break;
        case IDC_SHOWVERSION:
          break;
        } // end Switch(wParam)
      break;

    default:
      return FALSE;
    } //end switch(Message)

  return TRUE;
  } // AboutDlgProc                                 

//-----------------------------------------------------------------------------
//
//                       CustomMessageBox
//
// ... usage example 
// int msgID = CustomMessageBox(m_hWnd, _T("TEXT"), _T("Caption"), MB_OKCANCEL, IDI_ICON1);
//
int CustomMessageBox(HWND _hwnd, LPCTSTR lpText,  LPCTSTR lpCaption,
                                 UINT uType, UINT uIconResID)
   {
   MSGBOXPARAMS mbp;

   mbp.cbSize             = sizeof(MSGBOXPARAMS);
   mbp.hwndOwner          = _hwnd;                       // hMain
   mbp.hInstance          = GetModuleHandle(NULL);
   mbp.lpszText           = lpText;                      // Text within window
   mbp.lpszCaption        = lpCaption;                   // Text in window header
   mbp.dwStyle            = uType | MB_USERICON;         // Set Butoons and custom icon style
   mbp.dwLanguageId       = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);
   mbp.lpfnMsgBoxCallback = NULL;
   mbp.dwContextHelpId    = 0;
   mbp.lpszIcon           = MAKEINTRESOURCE(uIconResID); // Custom icon ID (haCrypt.rc)
   
   return MessageBoxIndirect(&mbp); // Returns button choice (e.g. msgID = IDYES, IDNO)
   } // CustomMessageBox

//-----------------------------------------------------------------------------
//
//                        CenterInsideParent
//
// Center a modal dialogbox defined in the resource file 'haCrypt.rc'
//
void CenterInsideParent(HWND hParent, char* pszDlgboxTitle)
  {
  // Getting the control positions & size
  RECT rcParent, rcDlgbox;

  // Getting the parent coordenates
  GetWindowRect(hParent, &rcParent);

  // Getting the dialogbox coordenates
  HWND hDlgbox = FindWindowA(NULL, pszDlgboxTitle);  // Ascii text in 'haCrypt.RC'
  GetWindowRect(hDlgbox, &rcDlgbox);

  // Calculate the center
  LONG _x = (rcParent.left + ((rcParent.right-rcParent.left)/2))  - ((rcDlgbox.right-rcDlgbox.left)/2);
  LONG _y = (rcParent.top  + ((rcParent.bottom-rcParent.top) /2)) - ((rcDlgbox.bottom-rcDlgbox.top) /2);

  //position the control
  SetWindowPos(hDlgbox, 0, _x, _y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
  } // CenterInsideParent


//-----------------------------------------------------------------------------
//
//                      - Centered Message Boxes -
//                         CBTSHBrowseForFolder
//                         CBTCustomMessageBox
//                         CBTMessageBox
//
// Message boxes are normally placed in the center of the desktop window.
// It is often desirable to create messages boxes over the parent app window.
// This cannot be done by using the standard Win32 API call:
// 
//  PIDLIST_ABSOLUTE CBTSHBrowseForFolder(BROWSEINFO bi);
//  int CustomMessageBox(HWND, LPCTSTR, LPCTSTR, UINT, UINT uIconResID);
//  int MessageBox(HWND, LPCTSTR, LPCTSTR, UINT);
// 
// The code below centers a message box over a parent window by using a
// CBT (computer-based training) hook. All message box calls are made with
// a substitute function called 'CBTMessageBox', which inserts the CBT hook
// prior to activating a message box.
// 
// The CBTProc function processes a thread-specific hook.
// The needed notification code is HCBT_ACTIVATE, which is issued whenever
// a new window is about to be activated (made visible).
// The wParam holds the forthcoming window handle value.
// The parent window handle is found using the GetForegroundWindow() function.
// 
// Centering is done by finding the center point of the parent window
// and by calculating the upper left corner starting point of the message box.
// The starting point will be adjusted if the message box dimensions
// exceed the desktop window region.
// 
// The CBT hook remains active until the necessary HCBT_ACTIVATE code is issued.
// Because several other CBT codes may be waiting in the hook queue
// when the SetWindowsHookEx call is made, it is useful to have the CBTProc
// continue the hook chain if another code is issued first.
// The CallNextHookEx function helps to ensure proper
// chaining of hooks issued by other apps.
// 
// The CBT hook process can be used to center any window to another.
// Just declare the hHook=SetWindowsHookEx function before activating a window.
//
//  Substitute
//      CBTSHBrowseForFolder(BROWSEINFO); 
//      CBTCustomMessageBox(HWND, LPCTSTR, LPCTSTR, UINT, UINT uIconResID);
//      CBTMessageBox(HWND, LPCTSTR, LPCTSTR, UINT);
//  instead of
//      SHBrowseForFolder(&bi);
//      CustomMessageBox(HWND, LPCTSTR, LPCTSTR, UINT, UINT uIconResID);
//      MessageBox(HWND, LPCTSTR, LPCTSTR, UINT);
//  to produce a centered message box.
//
HHOOK _hHook;   // Declare the hook handle as global

PIDLIST_ABSOLUTE CBTSHBrowseForFolder(BROWSEINFO bi)
  {
  _hHook = SetWindowsHookEx(WH_CBT, &CBTProc, 0, GetCurrentThreadId());
  return SHBrowseForFolder(&bi);
  }

int CBTCustomMessageBox(HWND _hwnd, LPCTSTR lpText, LPCTSTR lpCaption,
                        UINT uType, UINT uIconResID)
  {
  _hHook = SetWindowsHookEx(WH_CBT, &CBTProc, 0, GetCurrentThreadId());
  return CustomMessageBox(_hwnd, lpText, lpCaption, uType, uIconResID);
  }

int CBTMessageBox(HWND _hwnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)
  {
  _hHook = SetWindowsHookEx(WH_CBT, &CBTProc, 0, GetCurrentThreadId());
  return MessageBox(_hwnd, lpText, lpCaption, uType);
  }

//-----------------------------------------------------------------------------
//
//                           CBTProc (Thread)
//
// Change the text of the [Yes], [No], [Cancel] and [Make new folder] buttons
// The text should be always meaningful English.
// Center the MessageBox within the parent window.
// Keep the MessageBox within the Desktop limits.
//
// ID=0x3746 = [Make new folder] button is undocumented (but very useful here).
//
#define IDNEWFOLDER 0x3746 // Microsoft system specific undocumented ID

LRESULT CALLBACK CBTProc(int nCode, WPARAM wParam, LPARAM lParam)
  {
  HWND  hParentWnd, hChildWnd;    // MessageBox is "child"
  RECT  rParent, rChild, rDesktop;
  POINT pCenter, cStart;
  int   cWidth, cHeight;

  // Notification that a child window is about to be activated.
  // Child window handle is wParam
  if (nCode == HCBT_ACTIVATE)
    {
    // Set window handles
    hParentWnd = GetForegroundWindow();
    hChildWnd  = (HWND)wParam;

    // Change the text of the buttons: YES, NO, CANCEL, Make new folder, ...
    if (GetDlgItem(hChildWnd, IDYES) != NULL)            // IDYES = System defined
      SetDlgItemText(hChildWnd, IDYES, _T("Yes"));       // Always English text 'Yes'

    if (GetDlgItem(hChildWnd, IDNO) != NULL)             // IDNO = System defined
      SetDlgItemText(hChildWnd, IDNO, _T("No"));         // Always English text 'No'

    if (GetDlgItem(hChildWnd, IDNEWFOLDER) != NULL)      // 0x3746 = System specific
      SetDlgItemText(hChildWnd, IDNEWFOLDER, _T("Make new folder")); // Always English text

//ha//if (GetDlgItem(hChildWnd, IDOK) != NULL)           // IDOK = System defined
//ha//  UINT result = SetDlgItemText(hChildWnd, IDOK, _T("+ha+")); // Test

    // Check if GetCurrentThreadId() is SHBrowseForFolder()
    if (_cbtFolderFlag == (MULTIFILE_BROWSER_CRYPTO | MULTIFILE_BROWSER_RENAME)) // Browser Results Filter 
      {
      SetDlgItemText(hChildWnd, IDCANCEL, _T("Close"));  // Multifile Reslults Filter 'Rename' or 'Crypto'
      SetWindowText(hChildWnd, _T("File(s) processed")); // Browser's title field

      // Set focus on [Close] button (..default action if VK_RETURN key is pressed)
      SendMessage(hChildWnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hChildWnd, IDCANCEL), TRUE); // = [Close] button
      SendMessage(hChildWnd, BFFM_ENABLEOK, TRUE, 0);                                       // Grayed OK Button 
      }
    else if (_cbtFolderFlag == MULTIFILE_BROWSER_RENAME || // Browser selection
             _cbtFolderFlag == MULTIFILE_BROWSER_CRYPTO)
      {
      SetDlgItemText(hChildWnd, IDCANCEL, _T("Cancel")); // Multifile Selection 'Rename' or 'Crypto'
      SetWindowText(hChildWnd, _T("Select a folder"));   // Browser's title field
      }

    // Center the client message box within the parent window
    if ((hParentWnd != 0) && (hChildWnd != 0) &&
        (GetWindowRect(GetDesktopWindow(), &rDesktop) != 0) &&
        (GetWindowRect(hParentWnd, &rParent) != 0) &&
        (GetWindowRect(hChildWnd, &rChild) != 0))
      {
      // Calculate client message box dimensions
      cWidth  = (rChild.right  - rChild.left);
      cHeight = (rChild.bottom - rChild.top);

      // Calculate parent window center point
      pCenter.x = rParent.left + ((rParent.right- rParent.left)/2);
      pCenter.y = rParent.top  + ((rParent.bottom-rParent.top)/2);

      // Calculate client message box starting point position
      cStart.x = (pCenter.x - (cWidth/2));
      cStart.y = (pCenter.y - (cHeight/2));

      // Adjust if message box is off desktop
      // Note:
      //  Multifile Selection 'Rename' and 'Crypto' is done in (haBrowse.cpp).
      //  Multifile Results Filter positioning must be done in (haCryptWRL.cpp) 
      if (_cbtFolderFlag == FALSE)  // Default = (Custom)MessageBox(..) 
        {
        if (rDesktop.bottom < rParent.bottom) cStart.y = rParent.top-cHeight/2;
        if (rDesktop.right  < rParent.right ) cStart.x = rDesktop.right-cWidth;
        if (rParent.left    < rDesktop.left ) cStart.x = rDesktop.left;
        //if (rParent.top   < rDesktop.top  ) cStart.y = rDesktop.Top;  // Shouldn't occur)
        MoveWindow(hChildWnd, cStart.x, cStart.y, cWidth, cHeight, FALSE);
        }
      } // end if

    // Exit CBT hook
    UnhookWindowsHookEx(_hHook);
    } // end if (nCode)

  // Otherwise, continue with any possible chained hooks
  else CallNextHookEx(_hHook, nCode, wParam, lParam);
  return 0;
  } // CBTProc


//*****************************************************************************
//
//                      DialogProcMultiFile (Modal Dialog)
//
// Usage:
// In resource.rc: IDD_HACRYPT_FILEC DIALOG DISCARDABLE  Lft,Top,Wdh,Hgt
//
// Function can be used Anywhere in the source code:  
// DialogBox(g_hInst, MAKEINTRESOURCE(IDD_HACRYPT_FILEC), NULL, DialogProcMultiFile);
// EndDialog(_hwnd, 0);
//
// We take a look at DialogBox(), CreateDialog()'s sister function.
// The difference is that DialogBox() implements it's own message loop
// and does not return until the dialog is closed.
// CreateDialog() acts more like a window created with CreateWindowEx()
// in that it returns immediately and depends on your message loop
// to pump the messages as it does for your main window.
// DialogBox() creates Modal dialogs.
// CreateDialog() creates Modeless dialogs.
//
//  void DialogBoxW(
//    [in, optional]  hInstance,
//    [in]            lpTemplate,
//    [in, optional]  hWndParent,
//    [in, optional]  lpDialogFunc
//  );
//
//  INT_PTR DialogBoxParamW(
//    [in, optional] HINSTANCE hInstance,
//    [in]           LPCWSTR   lpTemplateName,
//    [in, optional] HWND      hWndParent,
//    [in, optional] DLGPROC   lpDialogFunc,
//    [in]           LPARAM    dwInitParam
//  );
//
HWND hCryptoTypeBox = NULL;
HWND hRenameTypeOldBox = NULL;
HWND hRenameTypeNewBox = NULL;
int _txtSelect;  // Flag to partly preselect text in dedicated modal dialogboxes

INT_PTR CALLBACK DialogProcMultiFile(HWND _hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
  {
  int i, len;

  switch(Message)
    {
    //--------------------------------------------------------------------------
    //
    //                        case WM_INITDIALOG:
    //
    // Set up the modal dialog boxes
    // Place them centered inside haCrypt main window

    case WM_INITDIALOG:
      _valAQ = 0;     // Initially clear the response flag

      CenterInsideParent(hMain, " ESC - Abort?");                           // IDD_HACRYPT_ESC
      CenterInsideParent(hMain, " Rename file extensions");                 // IDD_HACRYPT_FILEXR
      CenterInsideParent(hMain, " File extensions. Modify?");               // IDD_HACRYPT_FILEX
      CenterInsideParent(hMain, " Confirm large file overwrite");           // IDD_HACRYPT_FILECL  
      CenterInsideParent(hMain, " Confirm save as..");                      // IDD_HACRYPT_FILESAV
      CenterInsideParent(hMain, " Confirm file overwrite");                 // IDD_HACRYPT_FILEC
      CenterInsideParent(hMain, " AES /Encrypt (CBC Ciphertext stealing)"); // IDD_HACRYPT_EDITCRYPT
      CenterInsideParent(hMain, " Ascii-Hexadecimal to Binary conversion"); // IDD_HACRYPT_ASCHEX2BIN
      CenterInsideParent(hMain, " TEST-MODE");                              // IDD_HACRYPT_TEST_KEEP

      // Get IDD_.. from 'haCrypt.rc' resource and initialize the entitled IDC_..
      // Set up the modal dialog boxes, and initialize any default values
      switch(LOWORD(lParam))  
        {                     
        case IDD_HACRYPT_EDITCRYPT:                            // " AES /Encrypt (CBC Ciphertext stealing)"
          ShowActualKeyIv(0);                                  // Xfer  key into _tKeyIcvBuf
          SetDlgItemText(_hwnd, IDC_TEXT_AESKEY, _tKeyIcvBuf); // Set key from _tKeyIcvBuf
          ShowActualKeyIv(1);                                  // Xfer  key into _tKeyIcvBuf
          SetDlgItemText(_hwnd, IDC_TEXT_AESIV, _tKeyIcvBuf);  // Set IV from _tKeyIcvBuf
          break;

        case IDD_HACRYPT_TEST_KEEP:                                    // " Test"
          ShowActualKeyIv(0);                                          // Xfer  key into _tKeyIcvBuf
          SetDlgItemText(_hwnd, IDC_TEST_KEEPKEY, _tKeyIcvBuf);        // Set key from _tKeyIcvBuf
          ShowActualKeyIv(1);                                          // Xfer  key into _tKeyIcvBuf
          SetDlgItemText(_hwnd, IDC_TEST_KEEPIV, _tKeyIcvBuf);         // Set IV from _tKeyIcvBuf
          SetDlgItemText(_hwnd, IDC_TEST_KEEP, pszCurrentModeTooltip); // Set info from tooltip
          break;

        case IDD_HACRYPT_FILEC:                                // " Confirm file overwrite"
        case IDD_HACRYPT_FILECL:                               // " Confirm large file overwrite"
          SetDlgItemText(_hwnd, IDC_FILE_EXIST, _tDebugBuf);   // Set file info from _tDebugBuf
          break;

        case IDD_HACRYPT_FILESAV:                              // " Confirm save as.."
        case IDD_HACRYPT_ASCHEX2BIN:                           // " Ascii-Hexadecimal to Binary conversion"
          SetDlgItemText(_hwnd, IDC_LAST_CRYPTO, _tDebugBuf);  // Set info from _tDebugBuf
          break;

        case IDD_HACRYPT_FILEX:                                // " File extensions. Modify?" dialog
          SetDlgItemText(_hwnd, IDC_TEXT_X, szFileExtension);
          hCryptoTypeBox = GetDlgItem(_hwnd, IDC_TEXT_X);      // hCryptoTypeBox = Handle of IDC_TEXT_X
          _txtSelect = IDC_TEXT_X;                             // Preselect IDC_TEXT_XNEW
          break;

        case IDD_HACRYPT_FILEXR:                                    // " Rename file extensions" dialog
          SetDlgItemText(_hwnd, IDC_TEXT_XNEW, szDfltWildcards);    // Always empty pattern as new file extension.
          hRenameTypeNewBox = GetDlgItem(_hwnd, IDC_TEXT_XNEW);     // hRenameTypeNewBox = Handle of IDC_TEXT_XNEW
          hRenameTypeOldBox = GetDlgItem(_hwnd, IDC_TEXT_XOLD);     // hRenameTypeOldBox = Handle of IDC_TEXT_XOLD

          // Set focus on [Rename] button (..default action if VK_RETURN key is pressed)
          SendMessage(_hwnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(_hwnd, IDC_RENAME), TRUE); // = [Rename] button

          if (lstrlen(szExtensionSave) != 0)                        // Sample file w/ extension selected
            {
            SetDlgItemText(_hwnd, IDC_TEXT_XOLD, szExtensionSave);  // Put sample file extension into edit field
            _txtSelect = IDC_TEXT_XNEW;                             // Preselect IDC_TEXT_XNEW
            }
          else if (lstrlen(oldFileExtension) == 2 && lstrlen(szExtensionSave) == 0) // File w/o extemsion selected
            {
            SetDlgItemText(_hwnd, IDC_TEXT_XOLD, oldFileExtension); // Put empty pattern "*." into edit field
            _txtSelect = IDC_TEXT_XNEW;                             // Preselect IDC_TEXT_XNEW
            }
          else if (lstrlen(oldFileExtension) == 0 && lstrlen(szExtensionSave) == 0) // No sample file selected
            {
            SetDlgItemText(_hwnd, IDC_TEXT_XOLD, szDfltWildcards);  // Put default pattern "*.???" into edit field
            _txtSelect = IDC_TEXT_XOLD;                             // Preselect IDC_TEXT_XOLD
            }
          else
            SetDlgItemText(_hwnd, IDC_TEXT_XOLD, szDfltWildcards);  // Put empty pattern - shouldn't occur.

          // Truncate lenghty foldername displayed (must fit into window)
          if (lstrlen(szPathSave) > 38)
            {
            TruncateFilePath(szPathSave, 40, 1);
            SetDlgItemText(_hwnd, IDC_SHOWFOLDER, szTruncPath);
            }
          else // Display short foldername (fits the window)
            SetDlgItemText(_hwnd, IDC_SHOWFOLDER, szPathSave);
          break;
        } // end switch
      break; // end case WM_INITDIALOG:

    //--------------------------------------------------------------------------
    //
    //                        case WM_CTLCOLORSTATIC:
    //
    // Text Font & Color of special strings in some of the dialog boxes
    case WM_CTLCOLORSTATIC:
      switch(GetDlgCtrlID((HWND)lParam)) // Get IDC_.. from 'haCrypt.rc' resource
        {
        case IDC_LAST_CRYPTO:            // All strings displayd in dark green color
        case IDC_TEXT_AESKEY:
        case IDC_TEXT_AESIV:
        case IDC_TEST_KEEPKEY:
        case IDC_TEST_KEEPIV:
        case IDC_TEST_KEEP:
          { 
          // Select a font that's more legible with colored text
          SelectObject((HDC)wParam, SetFont(_T("Microsoft Sans Serif"), 15, 6));
          HBRUSH retVal = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
          SetTextColor((HDC)wParam, INFO_FGND); // Green
          SetBkMode((HDC)wParam, TRANSPARENT);
          return (INT_PTR)retVal;
          }
        default: // ..strange, but works!
          // -----------------------------------------------------------------
          // Preselect parts of the the string                                |
          // Set focus and show the preselected part of the string            |
          //  within the textbox according to EM_SETSEL at WM_INITDIALOG.     |
          //  (only done if multifile processing)                             |
          if (_txtSelect == IDC_TEXT_X)                                    // |
            {                                                              // |
            SendMessage(hCryptoTypeBox, EM_SETSEL, 1, -1);                 // |
            SetFocus(hCryptoTypeBox);                                      // |
            }                                                              // |
          if (_txtSelect == IDC_TEXT_XOLD)                                 // |
            {                                                              // |
            SendMessage(hRenameTypeOldBox, EM_SETSEL, 2, -1);              // |
            SetFocus(hRenameTypeOldBox);                                   // |
            }                                                              // |
          if (_txtSelect == IDC_TEXT_XNEW)                                 // |
            {                                                              // |
            SendMessage(hRenameTypeNewBox, EM_SETSEL, 2, -1);              // |
            SetFocus(hRenameTypeNewBox);                                   // |
            }                                                              // |
          // -----------------------------------------------------------------
          break;
        } // end switch
      return 0; // end case WM_CTLCOLORSTATIC:

    //--------------------------------------------------------------------------
    //
    //                        case WM_COMMAND:
    //
    // Serve the mouse clicks on the specific button
    case WM_COMMAND:
      switch(LOWORD(wParam))
        {
        // When somebody clicks the YES button
        case IDC_HACRYPT_YES:
          _valAQ = A_YES;
          EndDialog(_hwnd, 0);
          break;

        // When the user clicks the NO button, etc.
        case IDC_HACRYPT_NO:
          _valAQ = A_NO;
          EndDialog(_hwnd, 0);
          break;

        case IDC_HACRYPT_YESALL:
          _valAQ = A_YESALL;
          EndDialog(_hwnd, 0);
          break;

        case IDC_HACRYPT_NOALL:
          _valAQ = A_NOALL;
          EndDialog(_hwnd, 0);
          break;

        case IDCANCEL:            // ATTENTION: "case IDCANCEL:" captures ESC key
        case IDC_HACRYPT_CANCEL:
          _valAQ = A_CANCEL;
          EndDialog(_hwnd, 0);
          break;

        case IDC_TEST_PLAINTEXT:
          _valAQ = A_PLAINTEXT;
          EndDialog(_hwnd, 0);
          break;

        case IDC_TEST_KEY:
          _valAQ = A_KEY;
          EndDialog(_hwnd, 0);
          break;

        case IDC_TEST_IV:
          _valAQ = A_IV;
          EndDialog(_hwnd, 0);
          break;

        case IDC_TEST_SAVE:
          _valAQ = A_TESTSAVE;
          EndDialog(_hwnd, 0);
          break;

        case IDC_TEST_CRYPTO:
          _valAQ = A_CRYPTO;
          EndDialog(_hwnd, 0);
          break;

        // -------------------------------------------------------------------
        // ATTENTION: "case IDOK:" is needed to capture VK_RETURN             |
        //  while the textbox has focus. This serves as a convenient          |
        //  alternative to a mouse-click on the [Continue]-Button.            |
        // Note: It is NOT necessary to define IDOK in the resource.rc.       |
        // IDOK is always pre-defined and ready to be used appropriately.     |
        // IDOK can only appear here once. Because it will act on ALL         |
        // dialog text boxes, we restrict it to IDC_CONTINUE in order         |
        // to prevent incorrect actions at IDC_RENAME.                        |
        case IDOK:                                                          //|
          //if (_txtSelect != IDC_TEXT_X) break; // IDOK-Not if rename dialog |
          if (_txtSelect != IDC_TEXT_X)  // Fall thru if not "Rename" dialog  |
            goto caseRename;             // IDOK = for [Rename] button        |
        // -------------------------------------------------------------------
        case IDC_CONTINUE:
          {
          _valAQ = A_CONTINUE;
          // When somebody clicks the CONTINUE button:
          // We get the string entered.
          // First we need to find out how long it is,
          // so that we can allocate some memory.
          // Then we put the string into our buffer.
          len = GetWindowTextLength(GetDlgItem(_hwnd, IDC_TEXT_X));
          if (len > 0)
            GetDlgItemText(_hwnd, IDC_TEXT_X, szFileExtension, len + 1);

          EndDialog(_hwnd, 0);
          }
          break;

        // IDC_RENAME: Must mouse-click the button. VK_RETURN is not captured. 
        case IDC_RENAME:  
          {
//---------
caseRename:  // GOTO Label (the easiest solution at this point for IDOK)
//---------
          _valAQ = A_YES;

          // When somebody clicks the RENAME button:
          // We get the string(s) entered
          len = GetWindowTextLength(GetDlgItem(_hwnd, IDC_TEXT_XOLD));
          if (len > 0)
            {
            // Now we allocate, and get the string into our buffer
            GetDlgItemText(_hwnd, IDC_TEXT_XOLD, oldFileExtension, len + 1);
            if (oldFileExtension[0] != (WCHAR)'*' || oldFileExtension[1] != (WCHAR)'.') // || len == 0)
              {
              SetDlgItemText(_hwnd, IDC_TEXT_XOLD, szDfltWildcards);
              CBTCustomMessageBox(_hwnd, szErrorRename, szErrorFormat, MB_OK, IDI_HACRYPT_ICON);
              hRenameTypeOldBox = GetDlgItem(_hwnd, IDC_TEXT_XOLD);   // hRenameTypeOldBox = Handle of IDC_TEXT_XOLD
              SendMessage(hRenameTypeOldBox, EM_SETSEL, 2, -1);       // Preselect parts of the the string
              SetFocus(hRenameTypeOldBox);             
              return FALSE;
              }
            }
          len = GetWindowTextLength(GetDlgItem(_hwnd, IDC_TEXT_XNEW));
          if (len > 0)
            {
            GetDlgItemText(_hwnd, IDC_TEXT_XNEW, newFileExtension, len + 1);
            if (newFileExtension[0] != (WCHAR)'*' || newFileExtension[1] != (WCHAR)'.') // || len == 0)
              {
              SetDlgItemText(_hwnd, IDC_TEXT_XNEW, szDfltWildcards);
              CBTCustomMessageBox(_hwnd, szErrorRename, szErrorFormat, MB_OK, IDI_HACRYPT_ICON);
              hRenameTypeNewBox = GetDlgItem(_hwnd, IDC_TEXT_XNEW);   // hRenameTypeNewBox = Handle of IDC_TEXT_XNEW
              SendMessage(hRenameTypeNewBox, EM_SETSEL, 2, -1);       // Preselect parts of the the string
              SetFocus(hRenameTypeNewBox);             
              return FALSE;
              }
            else
              {
              for (i=0; i<=len-2; i++) newFileExtension[i+0] = newFileExtension[i+2];
              }
            }
          EndDialog(_hwnd, 0);
          }
          break; // end case IDC_RENAME:

        } // end switch(LOWORD(wParam))
      break; // end CASE WM_COMMAND:

    //--------------------------------------------------------------------------
    //
    //                        case WM_CLOSE:
    //
    case WM_CLOSE:
      EndDialog(_hwnd, 0);
      break;

    default:
      return FALSE;
    } // end switch(Message)

  return TRUE;
  } // DialogProcMultiFile

//-DEPRECATED------------------------------------------------------------------
//
//                       CreateMultifileDialog
//
// Usage: In function 'LRESULT CALLBACK WndProc(HWND hwnd,..)'
// In resource.rc: IDD_HACRYPT_FILEC DIALOGEX DISCARDABLE  Lft,Top,Wdh,Hgt
//  
//  if (!IsDialogMessage(hDlgFileExist, &msg))
//  CreateMultifileDialog(HWND _hwnd);
//  ShowWindow(hFileExists, SW_SHOW);
//  ShowWindow(hFileExists, SW_HIDE);
//  Destroy(hFileExists);
//
// Now we take a look at CreateDialog(), DialogBox()'s sister function.
// The difference is that while DialogBox() implements it's own message loop
// and does not return until the dialog is closed,
// CreateDialog() acts more like a window created with CreateWindowEx()
// in that it returns immediately and depends on your message loop
// to pump the messages as it does for your main window.
// This is termed 'Modeless', whereas DialogBox() creates 'Modal' dialogs.
//
//ha//void CreateMultifileDialog(HWND _hwnd)
//ha//  {
//ha//  hDlgFileExist = CreateDialog(
//ha//    GetModuleHandle(NULL), 
//ha//    MAKEINTRESOURCE(IDD_HACRYPT_FILEC),
//ha//    _hwnd, 
//ha//    DialogProcMultiFile;
//ha//    )
//ha//  //ShowWindow(hDlgFileExist, SW_HIDE);
//ha//  ShowWindow(hDlgFileExist, SW_SHOW);
//ha//  } // CreateMultifileDialog

//------------------------------------------------------------------------------

//ha////---DEBUG------DEBUG------DEBUG------DEBUG------DEBUG------DEBUG------DEBUG------DEBUG---
//ha//StringCbPrintf(_tDebugBuf, _tDebugbufSize, TEXT("lstrlen(oldFileExtension) = %i\nlstrlen(szExtensionSave) = %i"),
//ha//                                                 lstrlen(oldFileExtension), lstrlen(szExtensionSave));
//ha//MessageBox(NULL, _tDebugBuf, _T("DEBUG 0 haWintest - DoFileRename"), MB_ICONINFORMATION | MB_OK);
//ha////---DEBUG------DEBUG------DEBUG------DEBUG------DEBUG------DEBUG------DEBUG------DEBUG---

